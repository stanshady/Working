import javafx.application.Application;
import javafx.event.EventHandler;
import javafx.scene.Cursor;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.effect.Light;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.Pane;
import javafx.scene.layout.StackPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Line;
import javafx.scene.shape.Rectangle;
import javafx.scene.shape.Shape;
import javafx.scene.transform.Rotate;
import javafx.stage.Stage;

public class TestingASS extends Application {

    private Pane root;
    private double xCenter, yCenter;
    private double sideLen, swingLen;

    private Line base, side, swing, shortGreen, longGreen;
    private Circle circle, longEndPoint,shortEndPoint;
    private Rectangle rectangle;
    private double angle, rectangleAngle;

    //test
    private boolean dragOn;




    private Parent setUpScene() {

        //test
        dragOn = false;

        root = new Pane();
        root.setPrefSize(1000, 1000);

        base = new Line(100, 600, 950, 600);

        //ASS inputs
        angle = 40;
        sideLen = 400;
        swingLen = 320;

        side = new Line(base.getStartX(),
                base.getStartY(),
                base.getStartX() + sideLen*Math.cos(angle*Math.PI/180),
                base.getStartY() - sideLen*Math.sin(angle*Math.PI/180));



        swing = new Line(side.getEndX(),
                side.getEndY(),
                side.getEndX()+swingLen,
                side.getEndY());



        double deltaY = swing.getStartY() - base.getStartY();
        double deltaX = Math.sqrt(swingLen * swingLen - deltaY * deltaY);
        longGreen = new Line(base.getStartX(),
                base.getStartY(),
                swing.getStartX() + deltaX,
                base.getStartY());

        longGreen.setStroke(Color.GREEN);
        longGreen.setOpacity(0);
        longGreen.setStrokeWidth(7);




        rectangle = new Rectangle(swing.getStartX(), swing.getStartY(), 2000, 30);

        rectangleAngle = -1*Math.atan((longGreen.getEndY() - swing.getStartY()) / (longGreen.getEndX() - swing.getStartX()));


        System.out.println(rectangleAngle);
        double normalAngle = rectangleAngle + Math.PI * 0.5;

        //readjust along the perpendicular
        //had to use setLayoutX/Y.  setX() and setY() had
        //funny behavior.
        rectangle.setLayoutX(rectangle.getHeight() * 0.5 * Math.cos(normalAngle));
        System.out.println(swing.getStartX() + " " + rectangle.getHeight() * 0.5 * Math.cos(normalAngle));
        rectangle.setLayoutY(-1*rectangle.getHeight() * 0.5 * Math.sin(normalAngle));

        Rotate rotate = new Rotate(-1*rectangleAngle * 180 / Math.PI, swing.getStartX(), swing.getStartY());
        rectangle.getTransforms().addAll(rotate);


        System.out.println(normalAngle);

        System.out.println("Height = " + rectangle.getHeight());

        rectangle.setOpacity(0);

        rectangle.setOnMouseDragEntered(event -> {
            longGreen.setOpacity(1);
            base.setOpacity(0);
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());

        });

        rectangle.setOnMouseDragOver(event -> {
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());

        });


        rectangle.setOnMouseDragExited(event -> {
            longGreen.setOpacity(0);
            base.setOpacity(1);

            if(dragOn)
                event.consume();
            //testing
            else
                checkIntersection();
        });

        base.getStrokeDashArray().addAll(20d, 10d);

        swing.setStrokeWidth(3);
        side.setStrokeWidth(3);

        swing.setStroke(Color.RED);
        side.setStroke(Color.BLUE);


        longEndPoint = new Circle(longGreen.getEndX(), longGreen.getEndY(), 1);

        circle = new Circle(swing.getEndX(), swing.getEndY(), 7);

        swing.endXProperty().bind(circle.centerXProperty());
        swing.endYProperty().bind(circle.centerYProperty());

        circle.setCursor(Cursor.HAND);

        circle.setOnMousePressed(event -> {
            //testing
            dragOn = true;

            //when mouse is pressed, store initial position
            xCenter = circle.getTranslateX();
            yCenter = circle.getTranslateY();
            circle.setMouseTransparent(true);
        });

        circle.setOnMouseReleased(event -> {
            circle.setMouseTransparent(false);

            //testing
            dragOn = false;

            //Call to checkIntersection seems to do nothing...
            checkIntersection();

        });


        circle.setOnMouseDragged(event -> {

            double xDiff = event.getSceneX() - swing.getStartX();
            double yDiff = event.getSceneY() - swing.getStartY();
            double hypotenuse = Math.sqrt(yDiff * yDiff + xDiff * xDiff);

            circle.setCenterX(swing.getStartX() + swingLen * xDiff / hypotenuse);
            circle.setCenterY(swing.getStartY() + swingLen * yDiff / hypotenuse);


        });


        circle.setOnMouseEntered(event -> {
            //change the z-coordinate of the circle
            circle.toFront();
            circle.setOpacity(1);
        });


        //this is vital. Learn more about it
        circle.setOnDragDetected(event ->{
                circle.startFullDrag();
        });


        root.getChildren().addAll(swing,  base, side, longGreen, circle, rectangle);



        return root;
    }

    //slick way to check shape intersection.
    //.intersect() creates the Shape of the intersection.
    //We check if that shape has actual width (!= -1)

    //Let's use this for setOnMouseReleased?
    public void checkIntersection(){
        Shape intersect = Shape.intersect(circle, rectangle);
        if (intersect.getBoundsInLocal().getWidth() != -1) {
            circle.setCenterX(longGreen.getEndX());
            circle.setCenterY(longGreen.getEndY());
            longGreen.setOpacity(1);
            base.setOpacity(0);
        }
        else {
            longGreen.setOpacity(0);
            base.setOpacity(1);
        }
    }




    public double dist(Line line) {
        return Math.sqrt((line.getEndX() - line.getStartX()) * (line.getEndX() - line.getStartX()) +
                (line.getEndY() - line.getStartY()) * (line.getEndY() - line.getStartY()));
    }


    @Override
    public void start(Stage primaryStage) throws Exception {
        primaryStage.setScene(new Scene(setUpScene()));
        primaryStage.show();
    }
}
